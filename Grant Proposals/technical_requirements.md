# Comprehensive Technical Requirements: cadCAD ALife MVP

This document formalizes the engineering requirements for executing the **3-Month MVP** of the cadCAD ALife Research Program (as proposed by PI Octopus), mapped directly onto the existing Bio-Alpha cyber-physical infrastructure.

---

## Executive Summary: Implementation Priority (The "Lowest Hanging Fruit")

Based on the Generalized Dynamical Systems (GDS) literature (Zargham et al.), the research questions range extensively in complexity. 

**The absolute lowest hanging fruit is Part 2: Admissibility Enforcement (RQ2).** 
*   **Why:** Unlike RQ1 (Topological Sampling) or RQ3 (Inverse Inclusions) which require heavy, multi-dimensional calculus and custom solvers, RQ2 is purely a software engineering task. We already have the core boundary equation ($\Delta x_{token} + (c \cdot \Delta E_{physical}) = 0$). RQ2 simply requires building a Python schema-validation wrapper around the simulation step function to reject mathematically invalid state transitions. It delivers immediate, provable GDS safety guarantees with minimal computational overhead.

---

## Part 1: Topological Sampling & Reachability (RQ1)
**Goal:** Algorithmically characterize the Configuration Space ($X_C$) to identify reachable subspaces (viable basins of attraction) for the biological asset.

### 1.1 Generalized Cell Mapping Module
*   **Req 1.1.1 [cadCAD Integration]:** The system requires a `cell_mapping.py` module capable of interfacing with cadCAD's Monte Carlo parameter sweep engine.
*   **Req 1.1.2 [State Discretization]:** The continuous State Space (Temperature, CO2, Light, Capital) must be discretized into a finite grid of "cells."
*   **Req 1.1.3 [Markov Transition Mapping]:** The module must calculate the transition probabilities between these cells over a discrete time step $\Delta t$, generating a Markov transition matrix representing the system's "laws of physics" (State Update Map $f$).

### 1.2 Basin Identification
*   **Req 1.2.1 [Sink Cell Detection]:** The algorithm must identify absorbing states (e.g., Biological Death or Bankruptcy).
*   **Req 1.2.2 [Viable Basin Mapping]:** The algorithm must identify the set of all initial conditions (staring capital, starting plant health) that reliably route toward the desired optimal growth state rather than the absorbing failure states.

---

## Part 2: Admissibility Enforcement & Type Systems (RQ2)
**Goal:** Implement a Type-System Wrapper for cadCAD that enforces the Admissible Input Map ($U: X \to \wp(U)$) at the schema level.

> **What is a Type-System Wrapper?** 
> In software engineering, a type system blocks code from running if a variable is the wrong "type" (e.g., passing text into a math function). A "System Type Wrapper" for GDS admissibility extends this to system physics and economics. It is a strict interceptor (like a Python `@decorator` or `Pydantic` schema) that intercepts a controller's command *before* it reaches the system actuators. If an agent tries to execute `run_pump(10)` but `cost(10) > current_balance`, the wrapper throws an `AdmissibilityError` and blocks the transaction entirely, physically preventing the system from entering an impossible state.

### 2.1 The Invariant Engine ([EnergyInvariant](file:///c:/Users/coad1/OneDrive/Desktop/Projects/Tokenized-Bio-Hedge-Fund/bioalpha/invariant.py#27-80))
*   **Req 2.1.1 [Economic Coupling]:** The Agent Guard must mathematically link physical actions ($\Delta E_{physical}$) to necessary economic expenditure ($\Delta x_{token}$) via the conservation function: $\Delta x_{token} + (c \cdot \Delta E_{physical}) = 0$.
*   **Req 2.1.2 [Pre-Execution Hook]:** Before any decision generated by the Gemini orchestrator is passed to the physical (Arduino) State Update block, it must pass through an [is_admissible()](file:///c:/Users/coad1/OneDrive/Desktop/Projects/Tokenized-Bio-Hedge-Fund/bioalpha/invariant.py#47-61) boolean check. 
*   **Req 2.1.3 [Hardware Rejection Logging]:** If an action is mathematically inadmissible (e.g., trying to run the pump with no `$ALPHA`), the system must log a formal "Inadmissible Trajectory Blocked" event, ensuring the simulation cannot enter impossible physical states.

---

## Part 3: Modeling the Researcher as a GDS (RQ4)
**Goal:** Formalize the Researcher's Input Map ($g: X \to U_x$) to document the feedback loop between observation and decision-making.

> **Controlling the Feedback Loop:**
> Currently, the Bio-Alpha MVP uses the Gemini AI Swarm acting as the dynamic controller $g(x)$. However, to formally benchmark and optimize this feedback loop, the system should allow plugging in classical and modern control theory algorithms:
> *   **PID (Proportional-Integral-Derivative):** The simplest baseline controller to maintain fixed temperature/moisture targets.
> *   **LQR (Linear-Quadratic Regulator):** For optimizing standard state transitions over low-dimensional linear assumptions.
> *   **MPC (Model Predictive Control):** The strongest non-LLM candidate for this ALife system. MPC inherently uses an internal model of the plant to predict future states over a receding time horizon, optimizing resource spend vs. biological healthâ€”functioning exactly like an agent "planning ahead" to stay viable.

### 3.1 Orchestrator State Logging
*   **Req 3.1.1 [Controller Pluggability]:** The simulation architecture must be modular enough to swap the primary Actor between the Gemini LLM swarm, a PID controller, and an MPC solver to benchmark token efficiency.
*   **Req 3.1.2 [Policy Evolution Tracking]:** Decisions made by the active controller must be tracked over time to empirically measure how the policy $g(x)$ adapts to Algedonic signals (Karma/Treasury fluctuations).

---

## Part 4: Phase 2 Expansion (Inverse Inclusions - RQ3)
**Goal:** Utilize Differential Inclusions to perform "inverse mapping" to derive required **Governance Surfaces**.

### 4.1 Contingent Derivative Engine
*   **Req 4.1.1 [Viability Solver]:** Develop a mathematical solver capable of calculating the Contingent Derivative (Bouligand derivative) of the viability kernel defined in Part 1. 
*   **Req 4.1.2 [Boundary Computation]:** The solver must compute the boundary outward normals of the safe set $K$.

### 4.2 Backward Integration Pipeline
*   **Req 4.2.1 [Inverted Trajectory Generation]:** Implement a backward-time stepping algorithm starting from the boundary of the failure state. Compute the set of all trajectories that lead to this failure boundary to identify the absolute "Point of No Return" (the Governance Surface).
*   **Req 4.2.2 [Dynamic Constraint Injection]:** The [EnergyInvariant](file:///c:/Users/coad1/OneDrive/Desktop/Projects/Tokenized-Bio-Hedge-Fund/bioalpha/invariant.py#27-80) class must dynamically ingest these derived Governance Surfaces, predicting future failures mathematically before the primary AI swarm can make catastrophic errors.